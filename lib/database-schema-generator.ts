// Database Schema Generator
// Generiert Prisma Schema und CRUD-Operationen aus natürlicher Sprache

import { sendChatRequest, getProviderFromModel } from "./api-client";

export interface DatabaseEntity {
  name: string;
  fields: DatabaseField[];
  relations?: DatabaseRelation[];
}

export interface DatabaseField {
  name: string;
  type: "String" | "Int" | "Float" | "Boolean" | "DateTime" | "Json";
  isRequired: boolean;
  isUnique?: boolean;
  isId?: boolean;
  default?: string;
}

export interface DatabaseRelation {
  name: string;
  type: "one-to-one" | "one-to-many" | "many-to-many";
  targetEntity: string;
}

export interface GeneratedDatabaseCode {
  prismaSchema: string;
  apiRoutes: { path: string; content: string }[];
  types: string;
  hooks: string;
}

const SCHEMA_GENERATOR_PROMPT = `Du bist ein Experte für Datenmodellierung und Prisma ORM.
Deine Aufgabe: Analysiere die Beschreibung und erstelle ein vollständiges Datenmodell.

## OUTPUT FORMAT (JSON):
{
  "entities": [
    {
      "name": "User",
      "fields": [
        { "name": "id", "type": "String", "isId": true, "default": "cuid()" },
        { "name": "email", "type": "String", "isRequired": true, "isUnique": true },
        { "name": "name", "type": "String", "isRequired": false },
        { "name": "createdAt", "type": "DateTime", "default": "now()" }
      ],
      "relations": [
        { "name": "posts", "type": "one-to-many", "targetEntity": "Post" }
      ]
    }
  ]
}

## REGELN:
- Jede Entity braucht ein "id" Feld (String mit cuid() oder Int mit autoincrement())
- Füge immer createdAt/updatedAt hinzu
- Erkenne Beziehungen automatisch (User -> Posts = one-to-many)
- Verwende sinnvolle Feldtypen
- Denke an Validierung (unique, required)

Gib NUR valides JSON aus, keine Erklärungen.`;

export async function analyzeDataModel(
  description: string,
  apiKey: string,
  provider: "openai" | "anthropic" | "openrouter"
): Promise<DatabaseEntity[]> {
  const response = await sendChatRequest({
    messages: [
      { role: "system", content: SCHEMA_GENERATOR_PROMPT },
      { role: "user", content: `Erstelle ein Datenmodell für: ${description}` }
    ],
    model: provider === "openrouter" ? "openrouter/auto" : "gpt-4o",
    temperature: 0.2,
    maxTokens: 4000,
    apiKey,
    provider
  });

  try {
    // Parse JSON aus Response
    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("Keine JSON-Struktur gefunden");
    }
    const parsed = JSON.parse(jsonMatch[0]);
    return parsed.entities || [];
  } catch (error) {
    console.error("[Schema Generator] Parse error:", error);
    throw new Error("Konnte Datenmodell nicht parsen");
  }
}

export function generatePrismaSchema(entities: DatabaseEntity[]): string {
  let schema = `// Prisma Schema - Generated by AgentForge
// https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

`;

  for (const entity of entities) {
    schema += `model ${entity.name} {\n`;
    
    for (const field of entity.fields) {
      let line = `  ${field.name} `;
      line += field.type;
      
      if (!field.isRequired && !field.isId) {
        line += "?";
      }
      
      if (field.isId) {
        line += " @id";
      }
      if (field.isUnique) {
        line += " @unique";
      }
      if (field.default) {
        line += ` @default(${field.default})`;
      }
      
      schema += line + "\n";
    }
    
    // Relations
    if (entity.relations) {
      for (const relation of entity.relations) {
        if (relation.type === "one-to-many") {
          schema += `  ${relation.name} ${relation.targetEntity}[]\n`;
        } else if (relation.type === "one-to-one") {
          schema += `  ${relation.name} ${relation.targetEntity}?\n`;
        } else {
          schema += `  ${relation.name} ${relation.targetEntity}[]\n`;
        }
      }
    }
    
    schema += "}\n\n";
  }

  return schema;
}

export function generateApiRoutes(entities: DatabaseEntity[]): { path: string; content: string }[] {
  const routes: { path: string; content: string }[] = [];

  for (const entity of entities) {
    const entityLower = entity.name.toLowerCase();
    const entityPlural = entityLower + "s";

    // GET all + POST
    routes.push({
      path: `app/api/${entityPlural}/route.ts`,
      content: `import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

// GET all ${entity.name}s
export async function GET() {
  try {
    const ${entityPlural} = await prisma.${entityLower}.findMany({
      orderBy: { createdAt: "desc" }
    });
    return NextResponse.json(${entityPlural});
  } catch (error) {
    console.error("Error fetching ${entityPlural}:", error);
    return NextResponse.json({ error: "Failed to fetch ${entityPlural}" }, { status: 500 });
  }
}

// POST create ${entity.name}
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const ${entityLower} = await prisma.${entityLower}.create({
      data: body
    });
    return NextResponse.json(${entityLower}, { status: 201 });
  } catch (error) {
    console.error("Error creating ${entityLower}:", error);
    return NextResponse.json({ error: "Failed to create ${entityLower}" }, { status: 500 });
  }
}
`
    });

    // GET by ID + PUT + DELETE
    routes.push({
      path: `app/api/${entityPlural}/[id]/route.ts`,
      content: `import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";

interface Params {
  params: { id: string }
}

// GET single ${entity.name}
export async function GET(request: Request, { params }: Params) {
  try {
    const ${entityLower} = await prisma.${entityLower}.findUnique({
      where: { id: params.id }
    });
    if (!${entityLower}) {
      return NextResponse.json({ error: "${entity.name} not found" }, { status: 404 });
    }
    return NextResponse.json(${entityLower});
  } catch (error) {
    console.error("Error fetching ${entityLower}:", error);
    return NextResponse.json({ error: "Failed to fetch ${entityLower}" }, { status: 500 });
  }
}

// PUT update ${entity.name}
export async function PUT(request: Request, { params }: Params) {
  try {
    const body = await request.json();
    const ${entityLower} = await prisma.${entityLower}.update({
      where: { id: params.id },
      data: body
    });
    return NextResponse.json(${entityLower});
  } catch (error) {
    console.error("Error updating ${entityLower}:", error);
    return NextResponse.json({ error: "Failed to update ${entityLower}" }, { status: 500 });
  }
}

// DELETE ${entity.name}
export async function DELETE(request: Request, { params }: Params) {
  try {
    await prisma.${entityLower}.delete({
      where: { id: params.id }
    });
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting ${entityLower}:", error);
    return NextResponse.json({ error: "Failed to delete ${entityLower}" }, { status: 500 });
  }
}
`
    });
  }

  // Prisma client singleton
  routes.push({
    path: "lib/prisma.ts",
    content: `import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;
`
  });

  return routes;
}

export function generateTypes(entities: DatabaseEntity[]): string {
  let types = `// Generated TypeScript Types\n\n`;

  for (const entity of entities) {
    types += `export interface ${entity.name} {\n`;
    
    for (const field of entity.fields) {
      let tsType = "string";
      switch (field.type) {
        case "Int":
        case "Float":
          tsType = "number";
          break;
        case "Boolean":
          tsType = "boolean";
          break;
        case "DateTime":
          tsType = "Date";
          break;
        case "Json":
          tsType = "Record<string, unknown>";
          break;
      }
      
      const optional = !field.isRequired && !field.isId ? "?" : "";
      types += `  ${field.name}${optional}: ${tsType};\n`;
    }
    
    types += `}\n\n`;

    // Create/Update types
    types += `export type ${entity.name}CreateInput = Omit<${entity.name}, "id" | "createdAt" | "updatedAt">;\n`;
    types += `export type ${entity.name}UpdateInput = Partial<${entity.name}CreateInput>;\n\n`;
  }

  return types;
}

export function generateHooks(entities: DatabaseEntity[]): string {
  let hooks = `"use client";

import { useState, useCallback } from "react";

`;

  for (const entity of entities) {
    const entityLower = entity.name.toLowerCase();
    const entityPlural = entityLower + "s";

    hooks += `// ============================================================
// ${entity.name} Hooks
// ============================================================

export function use${entity.name}s() {
  const [${entityPlural}, set${entity.name}s] = useState<${entity.name}[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetch${entity.name}s = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const res = await fetch("/api/${entityPlural}");
      if (!res.ok) throw new Error("Failed to fetch");
      const data = await res.json();
      set${entity.name}s(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Unknown error");
    } finally {
      setLoading(false);
    }
  }, []);

  const create${entity.name} = useCallback(async (data: ${entity.name}CreateInput) => {
    setLoading(true);
    setError(null);
    try {
      const res = await fetch("/api/${entityPlural}", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data)
      });
      if (!res.ok) throw new Error("Failed to create");
      const created = await res.json();
      set${entity.name}s(prev => [created, ...prev]);
      return created;
    } catch (err) {
      setError(err instanceof Error ? err.message : "Unknown error");
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const update${entity.name} = useCallback(async (id: string, data: ${entity.name}UpdateInput) => {
    setLoading(true);
    setError(null);
    try {
      const res = await fetch(\`/api/${entityPlural}/\${id}\`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data)
      });
      if (!res.ok) throw new Error("Failed to update");
      const updated = await res.json();
      set${entity.name}s(prev => prev.map(item => item.id === id ? updated : item));
      return updated;
    } catch (err) {
      setError(err instanceof Error ? err.message : "Unknown error");
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const delete${entity.name} = useCallback(async (id: string) => {
    setLoading(true);
    setError(null);
    try {
      const res = await fetch(\`/api/${entityPlural}/\${id}\`, { method: "DELETE" });
      if (!res.ok) throw new Error("Failed to delete");
      set${entity.name}s(prev => prev.filter(item => item.id !== id));
    } catch (err) {
      setError(err instanceof Error ? err.message : "Unknown error");
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    ${entityPlural},
    loading,
    error,
    fetch${entity.name}s,
    create${entity.name},
    update${entity.name},
    delete${entity.name}
  };
}

`;
  }

  return hooks;
}

export async function generateDatabaseCode(
  description: string,
  apiKey: string,
  provider: "openai" | "anthropic" | "openrouter"
): Promise<GeneratedDatabaseCode> {
  // 1. Analysiere Beschreibung und erstelle Entities
  const entities = await analyzeDataModel(description, apiKey, provider);
  
  if (entities.length === 0) {
    throw new Error("Keine Entities im Datenmodell gefunden");
  }

  // 2. Generiere alle Code-Dateien
  const prismaSchema = generatePrismaSchema(entities);
  const apiRoutes = generateApiRoutes(entities);
  const types = generateTypes(entities);
  const hooks = generateHooks(entities);

  return {
    prismaSchema,
    apiRoutes,
    types,
    hooks
  };
}
